import _toConsumableArray from "babel-runtime/helpers/toConsumableArray";
import _Object$assign from "babel-runtime/core-js/object/assign";
import _regeneratorRuntime from "babel-runtime/regenerator";
import _defineProperty from "babel-runtime/helpers/defineProperty";
import _extends from "babel-runtime/helpers/extends";
import _Object$keys from "babel-runtime/core-js/object/keys";
import _JSON$stringify from "babel-runtime/core-js/json/stringify";
import _typeof from "babel-runtime/helpers/typeof";
import _slicedToArray from "babel-runtime/helpers/slicedToArray";
import _classCallCheck from "babel-runtime/helpers/classCallCheck";
import _createClass from "babel-runtime/helpers/createClass";
import { Observable, Subject, BehaviorSubject, of as $of, throwError as $throw, merge, concat } from "rxjs";

import { groupBy, partition, publishLast, refCount, map, withLatestFrom, publish, filter, mergeMap, concatMap, take, mapTo, distinctUntilChanged, bufferToggle, pluck, skip, switchMap, takeUntil, ignoreElements, tap, shareReplay, scan } from "rxjs/operators";

import Handle from "./handle";
import connectWS from "./util/connectWS";
import { applyPatch } from "fast-json-patch";

var Session = function () {
  function Session(config) {
    var _this = this;

    _classCallCheck(this, Session);

    var session = this;

    // closed signal
    this.closed$ = new Subject();

    // delta mode
    var delta = config.delta || false;

    // Suspended changes state
    var suspended$ = new BehaviorSubject(false);

    // Connect WS
    var ws$ = Observable.create(function (observer) {
      // If they supplied a WebSocket, use it. Otherwise, build one
      if (typeof config.ws !== "undefined") {
        observer.next(config.ws);
        observer.complete();
      } else {
        var ws = connectWS(config);

        ws.addEventListener("open", function (evt) {
          observer.next(ws);
          observer.complete();
        });
      }

      return;
    }).pipe(publishLast(), refCount());

    // On close signal, execute side effect to close the websocket
    this.closed$.pipe(withLatestFrom(ws$), take(1)).subscribe(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          close = _ref2[0],
          ws = _ref2[1];

      return ws.close();
    });

    // WebSocket close events
    var wsClose$ = ws$.pipe(switchMap(function (ws) {
      return Observable.create(function (observer) {
        ws.addEventListener("close", function (evt) {
          observer.next(evt);
          observer.complete();
        });
      });
    }),
    // Side effects when websocket gets closed
    tap(function () {
      // complete the requests stream
      requests$.complete();
      // complete the suspended stream
      suspended$.complete();
    }));

    // Requests
    var requests$ = new Subject();

    // Hook in request pipeline
    requests$.pipe(withLatestFrom(ws$), takeUntil(wsClose$)).subscribe(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          req = _ref4[0],
          ws = _ref4[1];

      var request = {
        id: req.id,
        handle: req.handle,
        method: req.method,
        params: req.params
      };

      // Set delta if necessary
      if (_typeof(config.delta) === "object") {
        var overrides = config.delta[req.qClass] || [];
        if (overrides.indexOf(req.method) > -1) {
          request.delta = true;
        }
      } else if (config.delta === true) {
        request.delta = true;
      }

      ws.send(_JSON$stringify(request));
    });

    // Responses
    var responses$ = ws$.pipe(concatMap(function (ws) {
      return Observable.create(function (observer) {
        ws.addEventListener("message", function (evt) {
          var response = JSON.parse(evt.data);
          observer.next(response);
        });

        ws.addEventListener("error", function (err) {
          observer.error(err);
        });

        ws.addEventListener("close", function () {
          observer.complete();
        });
      });
    }), publish(), refCount());

    // Link responses with requests
    var responsesWithRequest$ = requests$.pipe(
    // this prevents errors from going through the delta processing chain. is that appropriate?
    filter(function (response) {
      return !response.hasOwnProperty("error");
    }), mergeMap(function (req) {
      return responses$.pipe(filter(function (response) {
        return req.id === response.id;
      }), take(1), map(function (response) {
        return {
          request: req,
          response: response
        };
      }));
    }));

    // Responses with errors
    var errorResponses$ = responses$.pipe(filter(function (resp) {
      return resp.hasOwnProperty("error");
    }));

    // Split direct responses from delta responses

    var _responsesWithRequest = responsesWithRequest$.pipe(filter(function (reqResp) {
      return !reqResp.response.hasOwnProperty("error");
    }), partition(function (reqResp) {
      return !reqResp.response.delta;
    })),
        _responsesWithRequest2 = _slicedToArray(_responsesWithRequest, 2),
        directResponse$ = _responsesWithRequest2[0],
        deltaResponses$ = _responsesWithRequest2[1];

    // Apply JSON Patching to delta responses


    var deltaResponsesCalculated$ = deltaResponses$.pipe(groupBy(function (reqResp) {
      return reqResp.request.handle + " - " + reqResp.request.method;
    }), mergeMap(function (grouped$) {
      return grouped$.pipe(scan(function (acc, reqResp) {
        var response = reqResp.response;

        var resultKeys = _Object$keys(response.result);
        return _extends({}, reqResp, {
          response: _extends({}, reqResp.response, {
            result: resultKeys.reduce(function (patchedResult, key) {
              var currentPatches = response.result[key];
              // fix for enigma.js root path which is out of compliance with JSON-Pointer spec used by JSON-Patch spec
              // https://tools.ietf.org/html/rfc6902#page-3
              // https://tools.ietf.org/html/rfc6901#section-5
              var transformedPatches = currentPatches.map(function (patch) {
                return patch.path === "/" ? _extends({}, patch, { path: "" }) : patch;
              });
              return _extends({}, patchedResult, _defineProperty({}, key, applyPatch(patchedResult[key], transformedPatches).newDocument));
            }, acc.response.result)
          })
        });
      }, {
        response: {
          result: {}
        }
      }));
    }));

    // Merge the direct and delta responses back together and parse them
    var mappedResponses$ = merge(directResponse$.pipe(map(function (reqResp) {
      return reqResp.response;
    })), deltaResponsesCalculated$.pipe(map(function (reqResp) {
      return reqResp.response;
    }))).pipe(map(function (response) {
      var result = response.result;
      var resultKeys = _Object$keys(result);
      if (result.hasOwnProperty("qReturn") && result.qReturn.hasOwnProperty("qHandle")) {
        return {
          id: response.id,
          result: new Handle(_this, result.qReturn.qHandle, result.qReturn.qType)
        };
      } else if (resultKeys.length === 1) {
        return {
          id: response.id,
          result: result[resultKeys[0]]
        };
      } else {
        return response;
      }
    }));

    // Publish response stream
    var finalResponse$ = merge(mappedResponses$, errorResponses$).pipe(publish());

    // Connect the response stream
    var finalResponseSub = finalResponse$.connect();

    // Changes
    var changesIn$ = responses$.pipe(filter(function (f) {
      return f.hasOwnProperty("change");
    }), pluck("change"));

    // Buffer changes during suspends
    var changes$ = changesIn$.pipe(bufferInvalids(suspended$));

    // Session Notifications
    var notifications$ = merge(requests$.pipe(map(function (req) {
      return {
        type: "traffic:sent",
        data: req
      };
    })), responses$.pipe(map(function (resp) {
      return {
        type: "traffic:received",
        data: resp
      };
    })), changes$.pipe(map(function (changes) {
      return {
        type: "traffic:change",
        data: changes
      };
    })), suspended$.pipe(map(function (suspend) {
      return {
        type: "traffic:suspend-status",
        data: suspend
      };
    })), wsClose$.pipe(map(function (evt) {
      return {
        type: "socket:close",
        data: evt
      };
    })));

    // Sequence generator
    this.seqGen = /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var index;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              index = 1;

            case 1:
              if (!true) {
                _context.next = 6;
                break;
              }

              _context.next = 4;
              return index++;

            case 4:
              _context.next = 1;
              break;

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    })();

    _Object$assign(this, {
      ws$: ws$,
      requests$: requests$,
      finalResponse$: finalResponse$,
      changes$: changes$,
      suspended$: suspended$,
      notifications$: notifications$,
      delta: delta
    });
  }

  _createClass(Session, [{
    key: "ask",
    value: function ask(action) {
      var requestId = this.seqGen.next().value;

      var request = {
        id: requestId,
        jsonrpc: "2.0",
        handle: action.handle,
        method: action.method,
        params: action.params,
        qClass: action.qClass
      };

      this.requests$.next(request);

      return this.finalResponse$.pipe(filter(function (r) {
        return r.id === requestId;
      }), mergeMap(function (m) {
        if (m.hasOwnProperty("error")) {
          return $throw(m.error);
        } else {
          return $of(m);
        }
      }), map(function (m) {
        return m.result;
      }), take(1));
    }
  }, {
    key: "global",
    value: function global() {
      var _this2 = this;

      var globalHandle = new Handle(this, -1, "Global");

      // ask for a sample call to test that we are authenticated properly, then either pass global or pass the error
      return this.ws$.pipe(switchMap(function () {
        return _this2.ask({
          handle: -1,
          method: "GetUniqueID",
          params: [],
          qClass: "Global"
        });
      }), mapTo(globalHandle), publishLast(), refCount());
    }
  }, {
    key: "close",
    value: function close() {
      this.closed$.next(null);
    }
  }]);

  return Session;
}();

export default Session;


function bufferInvalids(status$) {
  return function (src$) {
    var values = [];
    var directStream$ = new Observable.create(function (observer) {
      return src$.pipe(withLatestFrom(status$)).subscribe(function (_ref5) {
        var _ref6 = _slicedToArray(_ref5, 2),
            val = _ref6[0],
            status = _ref6[1];

        if (status) {
          values.push.apply(values, _toConsumableArray(val));
        } else {
          observer.next(val);
        }
      }, function (err) {
        return observer.error(err);
      }, function () {
        return observer.complete();
      });
    });

    var bufferStream$ = status$.pipe(distinctUntilChanged(), filter(function (f) {
      return !f;
    }), map(function () {
      return values;
    }), filter(function (f) {
      return f.length > 0;
    }), takeUntil(concat(src$.pipe(ignoreElements()), $of(undefined))));

    return merge(directStream$, bufferStream$);
  };
}
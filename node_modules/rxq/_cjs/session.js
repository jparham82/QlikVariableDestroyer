"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _assign = require("babel-runtime/core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _defineProperty2 = require("babel-runtime/helpers/defineProperty");

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _extends3 = require("babel-runtime/helpers/extends");

var _extends4 = _interopRequireDefault(_extends3);

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _handle = require("./handle");

var _handle2 = _interopRequireDefault(_handle);

var _connectWS = require("./util/connectWS");

var _connectWS2 = _interopRequireDefault(_connectWS);

var _fastJsonPatch = require("fast-json-patch");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Session = function () {
  function Session(config) {
    var _this = this;

    (0, _classCallCheck3.default)(this, Session);

    var session = this;

    // closed signal
    this.closed$ = new _rxjs.Subject();

    // delta mode
    var delta = config.delta || false;

    // Suspended changes state
    var suspended$ = new _rxjs.BehaviorSubject(false);

    // Connect WS
    var ws$ = _rxjs.Observable.create(function (observer) {
      // If they supplied a WebSocket, use it. Otherwise, build one
      if (typeof config.ws !== "undefined") {
        observer.next(config.ws);
        observer.complete();
      } else {
        var ws = (0, _connectWS2.default)(config);

        ws.addEventListener("open", function (evt) {
          observer.next(ws);
          observer.complete();
        });
      }

      return;
    }).pipe((0, _operators.publishLast)(), (0, _operators.refCount)());

    // On close signal, execute side effect to close the websocket
    this.closed$.pipe((0, _operators.withLatestFrom)(ws$), (0, _operators.take)(1)).subscribe(function (_ref) {
      var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
          close = _ref2[0],
          ws = _ref2[1];

      return ws.close();
    });

    // WebSocket close events
    var wsClose$ = ws$.pipe((0, _operators.switchMap)(function (ws) {
      return _rxjs.Observable.create(function (observer) {
        ws.addEventListener("close", function (evt) {
          observer.next(evt);
          observer.complete();
        });
      });
    }),
    // Side effects when websocket gets closed
    (0, _operators.tap)(function () {
      // complete the requests stream
      requests$.complete();
      // complete the suspended stream
      suspended$.complete();
    }));

    // Requests
    var requests$ = new _rxjs.Subject();

    // Hook in request pipeline
    requests$.pipe((0, _operators.withLatestFrom)(ws$), (0, _operators.takeUntil)(wsClose$)).subscribe(function (_ref3) {
      var _ref4 = (0, _slicedToArray3.default)(_ref3, 2),
          req = _ref4[0],
          ws = _ref4[1];

      var request = {
        id: req.id,
        handle: req.handle,
        method: req.method,
        params: req.params
      };

      // Set delta if necessary
      if ((0, _typeof3.default)(config.delta) === "object") {
        var overrides = config.delta[req.qClass] || [];
        if (overrides.indexOf(req.method) > -1) {
          request.delta = true;
        }
      } else if (config.delta === true) {
        request.delta = true;
      }

      ws.send((0, _stringify2.default)(request));
    });

    // Responses
    var responses$ = ws$.pipe((0, _operators.concatMap)(function (ws) {
      return _rxjs.Observable.create(function (observer) {
        ws.addEventListener("message", function (evt) {
          var response = JSON.parse(evt.data);
          observer.next(response);
        });

        ws.addEventListener("error", function (err) {
          observer.error(err);
        });

        ws.addEventListener("close", function () {
          observer.complete();
        });
      });
    }), (0, _operators.publish)(), (0, _operators.refCount)());

    // Link responses with requests
    var responsesWithRequest$ = requests$.pipe(
    // this prevents errors from going through the delta processing chain. is that appropriate?
    (0, _operators.filter)(function (response) {
      return !response.hasOwnProperty("error");
    }), (0, _operators.mergeMap)(function (req) {
      return responses$.pipe((0, _operators.filter)(function (response) {
        return req.id === response.id;
      }), (0, _operators.take)(1), (0, _operators.map)(function (response) {
        return {
          request: req,
          response: response
        };
      }));
    }));

    // Responses with errors
    var errorResponses$ = responses$.pipe((0, _operators.filter)(function (resp) {
      return resp.hasOwnProperty("error");
    }));

    // Split direct responses from delta responses

    var _responsesWithRequest = responsesWithRequest$.pipe((0, _operators.filter)(function (reqResp) {
      return !reqResp.response.hasOwnProperty("error");
    }), (0, _operators.partition)(function (reqResp) {
      return !reqResp.response.delta;
    })),
        _responsesWithRequest2 = (0, _slicedToArray3.default)(_responsesWithRequest, 2),
        directResponse$ = _responsesWithRequest2[0],
        deltaResponses$ = _responsesWithRequest2[1];

    // Apply JSON Patching to delta responses


    var deltaResponsesCalculated$ = deltaResponses$.pipe((0, _operators.groupBy)(function (reqResp) {
      return reqResp.request.handle + " - " + reqResp.request.method;
    }), (0, _operators.mergeMap)(function (grouped$) {
      return grouped$.pipe((0, _operators.scan)(function (acc, reqResp) {
        var response = reqResp.response;

        var resultKeys = (0, _keys2.default)(response.result);
        return (0, _extends4.default)({}, reqResp, {
          response: (0, _extends4.default)({}, reqResp.response, {
            result: resultKeys.reduce(function (patchedResult, key) {
              var currentPatches = response.result[key];
              // fix for enigma.js root path which is out of compliance with JSON-Pointer spec used by JSON-Patch spec
              // https://tools.ietf.org/html/rfc6902#page-3
              // https://tools.ietf.org/html/rfc6901#section-5
              var transformedPatches = currentPatches.map(function (patch) {
                return patch.path === "/" ? (0, _extends4.default)({}, patch, { path: "" }) : patch;
              });
              return (0, _extends4.default)({}, patchedResult, (0, _defineProperty3.default)({}, key, (0, _fastJsonPatch.applyPatch)(patchedResult[key], transformedPatches).newDocument));
            }, acc.response.result)
          })
        });
      }, {
        response: {
          result: {}
        }
      }));
    }));

    // Merge the direct and delta responses back together and parse them
    var mappedResponses$ = (0, _rxjs.merge)(directResponse$.pipe((0, _operators.map)(function (reqResp) {
      return reqResp.response;
    })), deltaResponsesCalculated$.pipe((0, _operators.map)(function (reqResp) {
      return reqResp.response;
    }))).pipe((0, _operators.map)(function (response) {
      var result = response.result;
      var resultKeys = (0, _keys2.default)(result);
      if (result.hasOwnProperty("qReturn") && result.qReturn.hasOwnProperty("qHandle")) {
        return {
          id: response.id,
          result: new _handle2.default(_this, result.qReturn.qHandle, result.qReturn.qType)
        };
      } else if (resultKeys.length === 1) {
        return {
          id: response.id,
          result: result[resultKeys[0]]
        };
      } else {
        return response;
      }
    }));

    // Publish response stream
    var finalResponse$ = (0, _rxjs.merge)(mappedResponses$, errorResponses$).pipe((0, _operators.publish)());

    // Connect the response stream
    var finalResponseSub = finalResponse$.connect();

    // Changes
    var changesIn$ = responses$.pipe((0, _operators.filter)(function (f) {
      return f.hasOwnProperty("change");
    }), (0, _operators.pluck)("change"));

    // Buffer changes during suspends
    var changes$ = changesIn$.pipe(bufferInvalids(suspended$));

    // Session Notifications
    var notifications$ = (0, _rxjs.merge)(requests$.pipe((0, _operators.map)(function (req) {
      return {
        type: "traffic:sent",
        data: req
      };
    })), responses$.pipe((0, _operators.map)(function (resp) {
      return {
        type: "traffic:received",
        data: resp
      };
    })), changes$.pipe((0, _operators.map)(function (changes) {
      return {
        type: "traffic:change",
        data: changes
      };
    })), suspended$.pipe((0, _operators.map)(function (suspend) {
      return {
        type: "traffic:suspend-status",
        data: suspend
      };
    })), wsClose$.pipe((0, _operators.map)(function (evt) {
      return {
        type: "socket:close",
        data: evt
      };
    })));

    // Sequence generator
    this.seqGen = /*#__PURE__*/_regenerator2.default.mark(function _callee() {
      var index;
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              index = 1;

            case 1:
              if (!true) {
                _context.next = 6;
                break;
              }

              _context.next = 4;
              return index++;

            case 4:
              _context.next = 1;
              break;

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    })();

    (0, _assign2.default)(this, {
      ws$: ws$,
      requests$: requests$,
      finalResponse$: finalResponse$,
      changes$: changes$,
      suspended$: suspended$,
      notifications$: notifications$,
      delta: delta
    });
  }

  (0, _createClass3.default)(Session, [{
    key: "ask",
    value: function ask(action) {
      var requestId = this.seqGen.next().value;

      var request = {
        id: requestId,
        jsonrpc: "2.0",
        handle: action.handle,
        method: action.method,
        params: action.params,
        qClass: action.qClass
      };

      this.requests$.next(request);

      return this.finalResponse$.pipe((0, _operators.filter)(function (r) {
        return r.id === requestId;
      }), (0, _operators.mergeMap)(function (m) {
        if (m.hasOwnProperty("error")) {
          return (0, _rxjs.throwError)(m.error);
        } else {
          return (0, _rxjs.of)(m);
        }
      }), (0, _operators.map)(function (m) {
        return m.result;
      }), (0, _operators.take)(1));
    }
  }, {
    key: "global",
    value: function global() {
      var _this2 = this;

      var globalHandle = new _handle2.default(this, -1, "Global");

      // ask for a sample call to test that we are authenticated properly, then either pass global or pass the error
      return this.ws$.pipe((0, _operators.switchMap)(function () {
        return _this2.ask({
          handle: -1,
          method: "GetUniqueID",
          params: [],
          qClass: "Global"
        });
      }), (0, _operators.mapTo)(globalHandle), (0, _operators.publishLast)(), (0, _operators.refCount)());
    }
  }, {
    key: "close",
    value: function close() {
      this.closed$.next(null);
    }
  }]);
  return Session;
}();

exports.default = Session;


function bufferInvalids(status$) {
  return function (src$) {
    var values = [];
    var directStream$ = new _rxjs.Observable.create(function (observer) {
      return src$.pipe((0, _operators.withLatestFrom)(status$)).subscribe(function (_ref5) {
        var _ref6 = (0, _slicedToArray3.default)(_ref5, 2),
            val = _ref6[0],
            status = _ref6[1];

        if (status) {
          values.push.apply(values, (0, _toConsumableArray3.default)(val));
        } else {
          observer.next(val);
        }
      }, function (err) {
        return observer.error(err);
      }, function () {
        return observer.complete();
      });
    });

    var bufferStream$ = status$.pipe((0, _operators.distinctUntilChanged)(), (0, _operators.filter)(function (f) {
      return !f;
    }), (0, _operators.map)(function () {
      return values;
    }), (0, _operators.filter)(function (f) {
      return f.length > 0;
    }), (0, _operators.takeUntil)((0, _rxjs.concat)(src$.pipe((0, _operators.ignoreElements)()), (0, _rxjs.of)(undefined))));

    return (0, _rxjs.merge)(directStream$, bufferStream$);
  };
}
module.exports = exports["default"];